# Система рекомендации музыкальных треков: создание и тестирование


## Клонирование репозитория

Для начала клонируем репозиторий проекта:

```
git clone git@github.com:spolivin/mle-project-sprint-4-v001.git
```

## Виртуальное окружение

Активируем окружение следующей серией команд:

```bash
sudo apt-get update
sudo apt-get install python3.10-venv
python3.10 -m venv .venv_recsys_app
source .venv_recsys_app/bin/activate
pip install --no-cache-dir -r requirements.txt
```
> NOTE: При возникновении ошибок на этапе установки библиотек в вирутальную среду может быть необходимо установить другие необходимые пакеты для среды Ubuntu командой `sudo apt-get install build-essential`.

## Подготовка к запуску микросервиса

Перед тем как запустить микросервис, необходимо сначала загрузить файлы с данными рекомендаций из *S3*. Файлы являются довольно тяжелыми, так что такой способ подготовки был выбран для избежания перегруженности репозитория без надобности.

Необходимо выполнить следующие действия для загрузки данных:

1. Перейти в папку со скриптами, предназначенными для работы с *S3*:

```bash
cd s3_scripts
```

2. В директории находится несколько скриптов, среди которых требуемый это `download_file.py`, который в зависимости от указанных переменных загружает требуемый файл. Для работы сервиса необходимы следующие файлы (путь указан как в бакете *S3*):

    * `recsys/recommendations/recommendations.parquet`
    * `recsys/recommendations/similar.parquet` 
    * `recsys/recommendations/top_popular.parquet` 
    * `recsys/data/items.parquet`

Чтобы убедиться в наличии файлов в бакете можно воспользоваться заранее подготовленным скриптом для просмотра объектов в бакете:

```bash
python check_storage_contents.py
```

3. Теперь нужно производить загрузку файлов, правильно прописывая название загружаемого файла и его путь в коде `download_file.py`, например для загрузки `items.parquet` надо изменить следующие строки кода:

```python
FILE_NAME = "items.parquet"
S3_FILE_DIR = "recsys/data"
```

А например для загрузки остальных файлов (раскоментируя каждую из первых трех строк для загрузки одного файла):

```python
FILE_NAME = "top_popular.parquet"
#FILE_NAME = "similar.parquet"
#FILE_NAME = "recommendations.parquet"
S3_FILE_DIR = "recsys/recommendations"
```
 После указания файла и его пути в бакете файл загружается следующей командой:

```bash
python download_file.py
```

Файлы будут автоматически загружены в локальную директорию `data`.

Bucket name `s3-student-mle-20240523-34f645dbbf`

## Запуск микросервиса

Микросервис поделен на 4 модуля в папке `services`:

* [`recommendations_service.py`](service/recommendations_service.py) => Основное приложение, из которого запускается генерация рекомендаций всех типов 
* [`events_service.py`](service/events_service.py) => Сервис для добавления онлайн событий пользователю 
* [`features_service.py`](service/features_service.py) => Сервис для расчета онлайн рекомендаций, основанных на схожести треков
* [`recs_offline_service.py`](service/recs_offline_service.py) => Сервис для расчет офлайн рекомендаций

Для удобства и избежания ошибок с портами, запуск каждого сервиса был перенесен в *shell*-скрипты, где каждый из них запускается в отдельном окне терминала:

```bash
# Terminal window 1
sh run_main_app.sh
```
```bash
# Terminal window 2
sh run_events_service.sh
```
```bash
# Terminal window 3
sh run_features_service.sh
```
```bash
# Terminal window 4
sh run_recs_service.sh
```

После того как все сервисы успешно запустились (о чем будет свидетельствовать вывод в терминале об успешности запуска сервера), можно начать делать запросы к микросервису.

## Тестирования микросервиса

Тестирование сервиса можно запустить при помощи следующей команды:

```python
# Terminal window 5 (testing)
python test_service.py
```

Данный скрипт протестирует микросервис на следующих группах пользователей (с сохранением логов в файле [`test_service.log`](test_service.log)):

* Пользователи без персональных рекомендаций
* Пользователи с персональными рекомендациями, но без онлайн-истории
* Пользователи с персональными рекомендациями и онлайн-историей.

В соответствии с написанным сервисом, на эндпоинт `/recommendations` основного приложения будет отправляться запрос типа `{"user_id": user_id, "k": k}`, что выдаст после запроса *k*-рекомендаций для данного пользователя с учетом его онлайн-истории. Иными словами, при отсутствии какой-то онлайн-истории у пользователя будут выдаваться оффлайн-рекомендации через эндпоинт `/recommendations_offline`(при наличии персональных рекомендаций - персональные, а при их отсутствии - рекомендации топа прослушанных треков), а при ее наличии будут выдаваться смешанные рекомендации (онлайн и оффлайн) - эндпоинты `/recommendations_offline` и `/recommendations_online`.

Взглянем на логи в файле [`test_service.log`](test_service.log) после запуска скрипта тестирования чтобы разобраться, что нам сервис выдал:

1. Для начала получим 5 рекомендации для пользователя 5 и 1, у которых нет ни персональных рекомендаций, ни онлайн истории. Видим, что в обоих случаях рекомендации одни и те же, посколько сервис так настроен, что в случае отсутствия персональных рекомендаций рекомендуется топ популярных из `data/top_popular.parquet`.
2. Теперь проверим пользователя 28073, у которого есть персональные рекомендации, но нет онлайн истории. Рекомендации теперь другие, ведь мы подтянули его персональные рекомендации.
3. Теперь проверим наши смешанные рекомендации, которые расчитываются для пользователей с онлайн историей. Представим, что пользователь 54633 зашел на сайт и прослушал треки `[3911, 1168, 109123, 8449]`. Добавим эти события для него при помощи эндпоинта `\put` и проверим добавление событий через `\get`. Они добавились, проверим рекомендации сначала оффлайн, затем онлайн, а потом из смесь. 
## Стратегия смешивания рекомендаций

Как можно видеть в [коде основного приложения](service/recommendations_service.py), при наличии онлайн истории запускается смешивание онлайн и оффлайн рекомендаций. В данном случае ставим онлайн-рекомендации на нечетные места финального списка рекомендаций, а оффлайн - на четные.

## Другие детали

После окончания тестирования приложения, смешанные рекомендации сохраняются в файле [`recs_blended.json`](recs_blended.json), которые далее используются в ноутбуке [`data_viewer.ipynb`](data_viewer.ipynb) для подтягивания самих рекомендаций треков.

## Остановка сервисов

По окончании работы сервисы можно остановить через `Ctrl+C` в каждом терминальном окне.